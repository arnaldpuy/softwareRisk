% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/all_paths_fun.R
\name{all_paths_fun}
\alias{all_paths_fun}
\title{Enumerate entry-to-sink call paths and compute risk metrics at the node and path level}
\usage{
all_paths_fun(
  graph,
  alpha = 0.6,
  beta = 0.3,
  gamma = 0.1,
  complexity_col = "cyclomatic_complexity",
  weight_tol = 1e-08
)
}
\arguments{
\item{graph}{A directed \code{tidygraph::tbl_graph}. Graph nodes must have a \code{name}
attribute (i.e., \code{igraph::V(as.igraph(graph))$name}) and a numeric node
attribute specified by \code{complexity_col}.}

\item{alpha, beta, gamma}{Numeric non-negative weights for the risk score,
constrained such that \code{alpha + beta + gamma == 1} (within \code{weight_tol}).}

\item{complexity_col}{Character scalar. Name of the node attribute containing
cyclomatic complexity. Default \code{"cyclomatic_complexity"}.}

\item{weight_tol}{Numeric tolerance for enforcing the weight-sum constraint.
Default \code{1e-8}.}
}
\value{
A named list with two tibbles:
\describe{
\item{nodes}{Node-level metrics with columns \code{name}, \code{cyclomatic_complexity},
\code{indeg} (in-degree), \code{outdeg} (out-degree), \code{btw} (betweenness), \code{risk_score}.}
\item{paths}{Path-level metrics with columns \code{path_id}, \code{path_nodes},
\code{path_str}, \code{hops}, \code{path_risk_score}, \code{path_cc}, \code{gini_node_risk},
\code{risk_slope}, \code{risk_mean}, \code{risk_sum}}
}
}
\description{
Given a directed call graph (\code{tidygraph::tbl_graph}) with a node attribute for
cyclomatic complexity, this function:
\itemize{
\item computes node-level metrics (in-degree, out-degree, betweenness),
\item calculates a node risk score as a weighted combination of rescaled metrics,
\item enumerates all simple paths from entry nodes (in-degree = 0) to sink
nodes (out-degree = 0),
\item computes path-level summaries and a path-level risk score.
\item calculates a gini index and the slope of risk at the path-level.
}
}
\details{
The risk score for node \eqn{v_i} is computed as

\deqn{r_{(v_i)} = \alpha\,\tilde{C}_{(v_i)} + \beta\, \tilde{d}_{(v_i)}^{\text{in}} + \gamma\,\tilde{b}_{(v_i)}},

where the tilde \eqn{\tilde{}} refers to normalization and the weights \eqn{\alpha},
\eqn{\beta} and \eqn{\gamma} reflect the relative importance of complexity, coupling
and network position, with the constraint \eqn{\alpha + \beta + \gamma = 1}.

The path-level risk score is calculated as

\deqn{P_k = 1 - \prod_{i=1}^{n_k} (1 - r_{k(v_i)})\,,}

where \eqn{r_{k(v_i)}} is the risk of the \eqn{i}-th function in path \eqn{k} and
\eqn{n_k} is the number of functions in that path. The equation behaves like a
saturating OR-operator: \eqn{P_k} is at least as large as the maximum individual
function risk and monotonically increases as more functions on the path become risky,
approaching 1 when several functions have high risk scores.

The Gini index of path \eqn{k} is computed as

\deqn{G_k = \frac{\sum_i \sum_j |r_{k(v_i)} - r_{k(v_j)}|}{2 n_k^2 \bar{r}_k}\,,}

where \eqn{\bar{r}_k} is the mean node risk in path \eqn{k}.

Finally, the trend of risk is defined by the slope of the regression

\deqn{r_{k(v_i)} = \theta_{0k} + \theta_{1k}\, i + \epsilon_i \,,}

where \eqn{r_{k(v_i)}} is the risk score of the function at position \eqn{i} along
path \eqn{k} (ordered from upstream to downstream execution) and \eqn{\epsilon_i} is a residual term.

The returned \code{paths} tibble includes \code{path_cc}, a list-column giving the numeric
vector of cyclomatic complexity values in the same order as \code{path_nodes} /
\code{path_str}.
}
\examples{
# synthetic_graph is a tidygraph::tbl_graph with node attribute "cyclomatic_complexity"
data(synthetic_graph)
out <- all_paths_fun(graph = synthetic_graph, alpha = 0.6, beta = 0.3,
gamma = 0.1, complexity_col = "cyclo")
out$nodes
out$paths


}
